# GC类型总结

## **1、垃圾收集发生的时机**
#### 一般情况下**以下几种情况会发生垃圾回收**
>  - （1）当Eden区或者S区不够用了 
>  - （2）老年代空间不够用了 
>  - （3）方法区空间不够用了 
>  - （4）System.gc() 

## **2、不同GC区别**
#### 1、SerialGC
 它是一种单线程收集器，其在进行垃圾收集的时候需要暂停其他线程。
>  - 参数：-XX:+UseSerialGC
>  - 优点：简单高效，拥有很高的单线程收集效率 
>  - 缺点：收集过程需要暂停所有线程 
>  - 算法：复制算法 
>  - 适用范围：新生代 
>  - 应用：Client模式下的默认新生代收集器

#### 2、ParallelGC
      更关注系统的吞吐量
> 参数：-XX:+UseParallelGC
> 优点：在多CPU时，比Serial效率高。
> 缺点：收集过程暂停所有应用程序线程，单CPU时比Serial效率差。
> 算法：年轻代使用`拷贝-复制`，老年代使用`标记-清除-整理`
> 适用范围：新生代
> 应用：运行在Server模式下的虚拟机中首选的新生代收集器

#### 3、CMS GC
CMS(Concurrent Mark Sweep)收集器是一种以获取 最短回收停顿时间 为目标的收集器。
采用的是"标记-清除算法",整个过程分为4步
```
(1)初始标记 CMS initial mark 标记GC Roots能关联到的对象 Stop The World-- ->速度很快 
(2)并发标记 CMS concurrent mark 进行GC Roots Tracing 
(3)重新标记 CMS remark 修改并发标记因用户程序变动的内容 Stop The World 
(4)并发清除 CMS concurrent sweep
```
由于整个过程中，并发标记和并发清除，收集器线程可以与用户线程一起工作，所以总体上来
说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。 
优点：并发收集、低停顿 
缺点：产生大量空间碎咕泡学院
#### 4、G1 GC
使用G1收集器时，Java堆的内存布局与就与其他收集器有很大差别，它将整个Java堆划分为多个
大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再
是物理隔离的了，它们都是一部分Region（不需要连续）的集合。
> - 并行和并发
> - 分代收集
> - 空间整合(标记-整理算法)
> - 可预测的停顿(允许程序通过参数约定垃圾收集的时间)

- 和CMS同理，对响应时间要求高，吞吐量要求不太严格的
- 多核CPU，大内存JVM应用，Oracle 表示 G1 适用于堆大小为6GB以上的服务器应用程序。
